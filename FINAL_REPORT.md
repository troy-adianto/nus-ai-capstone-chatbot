# Integrated Chat Agent Documentation

## 1. Introduction

This document provides a comprehensive overview of the **Integrated Chat Agent**, a multi-agent system designed to handle a variety of user queries by routing them to specialized components. The agent can:

- Answer general questions
- Retrieve information from uploaded documents
- Provide weather forecasts
- Generate images
- Query databases
- Recommend events

## 2. Architecture

The system is built around a central routing agent that directs user input to one of several specialized agents. Each agent is responsible for a specific task, allowing for a **modular and scalable architecture**.

### 2.1. Architecture Diagram

```
┌─────────────────┐
│   User Input    │
└─────────┬───────┘
          │
          ▼
┌─────────┴───────────────┐
│  IntegratedChatAgent    │
│  (chat_agent method)    │
└─────────┬───────────────┘
          │
          ▼
┌─────────┴───────────────┐
│   Query Router (LLM)    │
│ (route_query method)    │
└──┬──┬─────────┬──┬──┬──┘
   │  │         │  │  │
   ▼  ▼         ▼  ▼  ▼
┌──┴──┴─────────┴──┴──┴──┐
│General│Weather│DB│Image│Recommend│
│ Agent │ Agent │Ag│Agent│  Agent  │
└──┬──┬─────────┬──┬──┬──┘
   │  │         │  │  │
   ▼  ▼         ▼  ▼  ▼
┌──┴──┴────┬────┴──┴──┴──┐
│ RAG  │Weather│SQLite │Replicate│Event│
│Chain │  API  │  DB   │   API   │ DB  │
└──────┴───────┴───────┴─────────┴─────┘
```

### 2.2. Component Descriptions

**IntegratedChatAgent**: The main class that orchestrates the entire process. It initializes all the components and contains the primary `chat_agent` method.

**Query Router**: A core component that uses a large language model (LLM) to analyze the user's query and decide which specialized agent should handle it.

**General Agent**: Handles general conversation and questions related to uploaded documents using a Retrieval-Augmented Generation (RAG) approach with a vector store (Chroma).

**Weather Agent**: Fetches current or forecasted weather information using a third-party Weather API.

**Database Agent**: Translates natural language queries into SQL to retrieve information from an internal SQLite database about employees and departments.

**Image Agent**: Generates images from text prompts using the Replicate API.

**Recommendation Agent**: Suggests events based on date and weather by querying an internal events database and using the Weather API.

## 3. Multi-Agent Routing Implementation

The multi-agent approach is centered around the `route_query` method. This function is the **intelligent dispatcher** that ensures a user's request is handled by the most capable component.

### 3.1. Routing Process

1. **Input Analysis**: When a user sends a message to the `chat_agent`, the query is first passed to the `route_query` method.

2. **LLM-based Classification**: `route_query` constructs a prompt that asks a powerful LLM (GPT-4) to classify the user's query into one of several predefined categories:
   - `general`
   - `weather` 
   - `database`
   - `image`
   - `recommendation`

3. **Category Mapping**: The single-word category returned by the LLM directly maps to a corresponding handler method within the `IntegratedChatAgent` class (e.g., "weather" maps to `handle_weather_query`).

4. **Specialized Handling**: The `chat_agent` method then calls the appropriate handler based on the router's decision. Each handler is specifically designed for its domain, interacting with the necessary APIs, databases, or chains to fulfill the request.

5. **Fallback Mechanism**: If the routing fails or returns an invalid category, the system defaults to the general agent to ensure a response is always provided.

This routing mechanism allows the system to seamlessly integrate diverse functionalities into a single, cohesive chat interface.

## 4. User APIs and High-Level Flow

The primary ways a user interacts with the system are through the `chat_agent` for conversations and `upload_document` for providing knowledge.

### 4.1. `chat_agent(question: str)`

This is the **main entry point** for all user queries.

**Description**: Takes a user's question as a string, routes it to the appropriate specialized agent, and returns a formatted string response.

**Parameters**:
- `question` (str): The user's input message.

**Returns**: `str` - A textual response generated by the appropriate agent.

#### High-Level Flow:

1. User calls `chat_agent` with a question
2. The method calls `route_query` to determine the query type
3. Based on the route, it calls the corresponding internal handler:
   - `handle_weather_query`
   - `handle_database_query`
   - `handle_image_query`
   - `handle_recommendation_query`
   - etc.
4. The handler processes the request (e.g., calls an external API, queries a database)
5. The handler formats the result into a user-friendly string
6. If the query was routed to the general agent, the user's question and the agent's response are saved to the conversation memory to provide context for follow-up questions
7. The final string is returned to the user

#### Memory and Conversation History

The agent retains the history of conversations handled by the **General Agent** using LangChain's `ConversationBufferMemory`. This memory is crucial for answering follow-up questions related to uploaded documents or general topics. 

For instance, if you ask *"What was the revenue?"*, and then *"What about the profit?"*, the memory allows the agent to understand that the second question is also about the previously discussed document. 

> **Note**: Interactions with the other specialized agents (Weather, Database, etc.) are stateless and are not retained in this conversational memory.

### 4.2. `upload_document(document_path: str)`

This API is used to add new documents to the agent's knowledge base.

**Description**: Loads a PDF document from the given path, splits it into chunks, generates embeddings, and adds it to the Chroma vector store for retrieval by the General Agent.

**Parameters**:
- `document_path` (str): The local file path to the PDF document.

**Returns**: `bool` - `True` if the document was loaded successfully, `False` otherwise.

#### High-Level Flow:

1. User calls `upload_document` with a file path
2. The method uses `PyMuPDFLoader` to load the document content
3. The content is split into smaller, manageable chunks
4. The `OpenAIEmbeddings` model converts these chunks into vector embeddings
5. The embeddings are stored in the Chroma vector store
6. The `ConversationalRetrievalChain` is updated to use the new information in the vector store

## 5. Integration with 3rd Party Services

The agent leverages several external services to enhance its capabilities.

### 5.1. OpenAI (GPT-3.5-Turbo & GPT-4)

**Usage**: Used for the core logic of the General Agent (RAG), SQL query generation, weather function calling, and the critical `route_query` classification.

**Integration Point**: `ChatOpenAI`, `OpenAIEmbeddings`, and direct `openai.chat.completions.create` calls throughout the class.

### 5.2. Replicate (Imagen 4)

**Usage**: Powers the text-to-image generation functionality.

**Integration Point**: The `handle_image_query` method calls `replicate.run` with the user's prompt to generate an image.

### 5.3. Weather API (weatherapi.com)

**Usage**: Provides real-time and forecasted weather data.

**Integration Point**: The `_get_weather` method makes HTTP GET requests to the Weather API endpoint. This is used by both the `handle_weather_query` and `handle_recommendation_query` methods.

## 6. Debugging and Improvements

### 6.1. Debugging Strategy 

A systematic approach was used to test and debug the system:

#### Component-wise Testing
Each agent was tested in isolation to ensure its core functionality worked correctly:

- **General Agent**: Tested by asking questions before and after uploading a document
- **Database Agent**: Tested with direct natural language queries like *"Who has the highest salary?"*
- **Weather Agent**: Tested by asking for weather in different locations and for different dates
- **Image Agent**: Tested with various creative prompts
- **Recommendation Agent**: Tested by asking for event suggestions for specific dates and locations

#### Routing Integration Testing
After confirming individual components worked, the `route_query` function was tested with a wide range of ambiguous questions to see how it would classify them.

### 6.2. Routing Challenges and Solutions

During testing, a key issue emerged: **the initial routing was not always accurate**.

#### Problem
Ambiguous terms caused misclassification. For example, questions containing the word "salary" were sometimes routed to the general RAG agent (expecting to find salary information in a financial report) instead of the database agent.

#### Solutions Implemented

1. **More Restrictive Prompting**: The routing prompt was refined to be more specific. For the "database" category, the description was changed to: 
   > *"SQL queries only about employees and their salary (not about external documents or other company related information)"*
   
   This explicit negative constraint helps the LLM avoid misrouting financial report queries.

2. **Upgraded Routing Model**: The model for the `route_query` function was upgraded from `gpt-3.5-turbo` to `gpt-4`. GPT-4 has more advanced reasoning capabilities, leading to more nuanced and accurate classification, significantly improving the routing precision.

3. **Adjusted Model Temperature**: The temperature for the routing model was set to `1`. While a lower temperature is typically used for deterministic tasks, increasing it to `1` encourages the model to be more creative in its classification. This helps prevent the router from defaulting to an incorrect category when faced with ambiguous terms that could fit multiple contexts.

---

## Conclusion

The Integrated Chat Agent successfully demonstrates a sophisticated multi-agent architecture that can handle diverse user queries through intelligent routing. The system's modular design allows for easy extension and maintenance, while the comprehensive debugging process has resulted in a robust and reliable solution.

The integration of multiple AI services (OpenAI, Replicate, Weather API) showcases the potential for creating powerful, multi-modal AI assistants that can seamlessly handle a wide range of user needs in a single conversational interface.